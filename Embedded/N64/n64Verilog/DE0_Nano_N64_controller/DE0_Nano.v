
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE0_Nano(

	//////////// CLOCK //////////
	CLOCK_50,
	i_clk,
	in_rst,

	//////////// LED //////////
	LED,
	o_led,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	GPIO,
	GPIO_IN,
	
	io_n64_joypad_1
	
	//////////// UART //////////
	//o_uart
);

//=======================================================
//  PARAMETER declarations
//=======================================================

 
//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input								i_clk;
input								in_rst;

//////////// LED //////////
output		     [7:0]		LED;
output		     [7:0]		o_led;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// SW //////////
input 		     [3:0]		SW;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout 		    [33:0]		GPIO;
input 		     [1:0]		GPIO_IN;

inout								io_n64_joypad_1;


//=======================================================
//  REG/WIRE declarations
//=======================================================


wire pll_rst;
assign pll_rst = ~in_rst;

wire n64_clk;
wire n_rst;

wire [33:0]buttons_sig;
wire is_connected;
assign o_led[7:0]=buttons_sig[7:0];

wire alive;

////////// UART //////////
wire uart_start_pulse;
wire [7:0]uart_byte;
wire uart_busy;
wire uart_tx;
assign uart_byte[7:0] = buttons_sig[7:0];


//=======================================================
//  Structural coding
//=======================================================

PLL	PLL_inst (
	.areset ( pll_rst ),
	.inclk0 ( i_clk ),
	.c0 (  ),
	.c1 (  ),
	.c2 ( n64_clk ),
	.locked ( n_rst )
	);

N64_controller N64_controller_inst
(
	.clk_50MHZ(n64_clk) ,	// input  clk_50MHZ_sig
	.data(io_n64_joypad_1) ,	// inout  data_sig
	.start(1'b1) ,	// input  start_sig
	.buttons(buttons_sig[33:0]),	// output [33:0] buttons_sig
	.alive(alive)
); 

// Detekcija da je N64 poruka spremna
reg alive_d = 1'b0;
always @(posedge n64_clk) begin
	alive_d <= alive;		// jedan takt kaÅ¡njenja
end
assign uart_start_pulse = alive ^ alive_d;		// XOR = impuls

UART_TX #(
	.g_CLKS_PER_BIT(434)
) uart_tx_inst (
	.i_Clk (n64_clk),
	.i_TX_DV (uart_start_pulse),
	.i_TX_Byte (uart_byte[7:0]),
	.o_TX_Active (uart_busy),
	.o_TX_Serial (uart_tx),
	.o_TX_Done ( )
);




endmodule
